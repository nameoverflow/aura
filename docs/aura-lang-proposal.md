# Aura: An AI-Native Programming Language

## Proposal v0.6

---

## 1. Vision

Aura is a programming language designed for the AI era. Its core principle: **any code snippet should be fully understandable in isolation with minimal context**.

Traditional languages optimize for human cognitive patterns—familiarity, flexibility, expressiveness. Aura optimizes for a different constraint: **token efficiency and context-completeness** when code is read, analyzed, and generated by AI systems.

This doesn't mean Aura is hostile to humans. The same properties that help AI—explicitness, predictability, locality—also reduce cognitive load for human readers. Aura aims to be the intersection of human readability and AI parseability.

---

## 2. Core Design Principles

### 2.1 Context-Completeness

Any function, module, or code block should contain enough information to understand its behavior without fetching other files.

**Anti-pattern (other languages):**
```javascript
import { process } from "./utils"
// What does process do? What are its side effects? Unknown.
```

**Aura approach:**
- Effects are visible in signatures
- Types carry semantic meaning
- Tooling generates expanded context on demand

### 2.2 Semantic Density

Minimize tokens while maximizing expressed intent. Every token should carry meaning.

**Guidelines:**
- No boilerplate
- No ceremony
- No redundant syntax
- But also: no ambiguity-creating brevity

### 2.3 Explicit Over Implicit

Nothing is hidden. State changes, dependencies, effects, capabilities—all visible. **The written signature is always the real signature.**

**Forbidden patterns:**
- Global mutable state
- Implicit conversions
- Convention-based behavior (magic)
- Hidden signature transformations
- Metaprogramming that obscures control flow

### 2.4 Predictability

One canonical way to accomplish common tasks. Consistency compresses—both for AI training and for codebase coherence.

### 2.5 Flat and Local

Shallow hierarchies preferred. Related code lives together. Deep nesting is a code smell (but not forbidden—see Module section).

---

## 3. Language Features

### 3.1 Type System

Aura uses a strong, static type system with inference. Types are not just for correctness—they're documentation for AI.

```aura
type UserStatus = Active | Suspended | Deleted

type User {
  id: UUID
  name: String
  email: Email
  created: Timestamp
  status: UserStatus
}

// Generic product type
type Pair a b {
  first: a
  second: b
}
```

**Sum types** are always named and nominal (distinct even if variants match):

```aura
type Status = Pending | Processing | Complete | Failed String
```

**Variant resolution:** In pattern matching, bare variant names are resolved by the type being matched. In expressions where the type is ambiguous, qualify with the type name (e.g., `Status.Pending`). When the expected type is known from context (function arguments, assignment to a typed binding), bare variants are permitted.

**Product type (tuple) syntax:** The type is written `A * B * C`; values are written `(a, b, c)` and destructured the same way: `let (x, y, z) = tuple`.

**Features:**
- Algebraic data types (sum and product types)
- Refined types with runtime validation (see Section 3.6)
- No null—use `Option a`
- No exceptions—use `Result a e`

### 3.2 Concepts

Concepts define shared behavior across types. They are the foundation for generic programming.

```aura
concept Display {
  def display(self) -> String
}

concept Ord: Eq {
  def compare(self, other: Self) -> Ordering
}

concept Add (rhs = Self) {
  type Output
  def add(self, other: rhs) -> Self.Output
}

// Implementation
instance Display for User {
  def display(self) -> String = "User({self.id}): {self.name}"
}

// Concept bounds on generics
max: forall (Ord a). a * a -> a
def max(a, b) = if a.compare(b) == Greater { a } else { b }
```

**Built-in concepts:**
- `Eq`, `Ord` — equality and ordering
- `Add`, `Sub`, `Mul`, `Div` — arithmetic
- `Display`, `Debug` — string conversion
- `Default` — default values
- `Clone`, `Copy` — value duplication
- `Hash` — hashing for collections
- `From a`, `Into a` — type conversions (implement `From`; `Into` is auto-derived)

**Note on operator concepts:** The `+` operator is syntactic sugar for `Add.add(a, b)`, and likewise for `-`/`Sub`, `*`/`Mul`, `/`/`Div`. Similarly, `==` and `!=` desugar to `Eq` methods, and `<`, `>`, `<=`, `>=` desugar to `Ord` methods. This is concept-based dispatch, not ad-hoc operator overloading — the behavior of each operator is always determined by the corresponding concept implementation for the operand types.

### 3.3 Functions

Functions are the primary unit of organization.

```aura
def calculate_total(items: List LineItem) -> Decimal = {
  items
    |> filter((item) -> item.taxable)
    |> map((item) -> item.price * item.quantity)
    |> sum
}
```

**Features:**
- Pipeline operator `|>` for data flow
- Explicit lambda syntax `(args) -> expr` for clarity
- Expression-based (last expression is return value)
- Early exit via explicit `return` keyword; no implicit mid-function returns

**Standalone type annotations** are used for polymorphic functions that need `forall` to declare concept bounds. For monomorphic functions, inline parameter types are sufficient:

```aura
// Monomorphic: inline types only
def add(a: Int, b: Int) -> Int = a + b

// Polymorphic: standalone annotation with forall for concept bounds
max: forall (Ord a). a * a -> a
def max(a, b) = if a.compare(b) == Greater { a } else { b }
```

All free lowercase type and effect variables in a signature are implicitly universally quantified. `forall` is only needed to attach concept bounds.

**Closures** capture variables by reference. Captured values are stored in GC-allocated environment structs. A closure that outlives its creation scope keeps captured values alive through GC reachability. Closures are themselves GC-managed values.

**Pipeline operator semantics:**
- `a |> f(b, c)` desugars to `f(a, b, c)` — LHS becomes the first argument
- `a |> f` desugars to `f(a)` — bare function application
- `a |> .method(b)` desugars to `a.method(b)` — method call syntax

### 3.4 Tracked Effects

Effects are declared in function signatures and checked by the compiler. This is an **effect capability system**—functions declare what external capabilities they require. The compiler verifies that callers have the required capabilities.

```aura
def fetch_user(id: UUID) -> Result User DbError [Db.Read] = {
  Db.query_one("SELECT * FROM users WHERE id = ?", id)
}

def create_user(data: UserInput) -> Result User CreateError [Db.Write, Log, Time, Random] = {
  let user = User {
    id: Uuid.new(),
    name: data.name,
    email: data.email,
    created: Time.now(),
    status: Active
  }
  Log.info("Creating user: {user.id}")
  Db.insert(user)
}
```

**Effect categories** (capability-level granularity):

| Effect | Description |
|--------|-------------|
| `Db.Read` | Read from database |
| `Db.Write` | Write to database |
| `Net` | Network/HTTP requests |
| `Fs.Read` | Read from file system |
| `Fs.Write` | Write to file system |
| `Log` | Logging (any level) |
| `Time` | Access current time |
| `Random` | Randomness |
| `Env` | Environment variables |

**Design principles:**
- Effects track *capabilities*, not operational details (e.g., `Log`, not `Log.Info`)
- Log level is a runtime parameter, not a capability distinction
- A function with no effects is pure and can be safely parallelized, memoized, or reordered
- A function with no effect list is pure; an explicit empty list `[]` is equivalent but optional

**Why this matters for AI:**
- Knows exactly what a function can do
- Can determine if functions are pure
- Can identify parallelization opportunities
- Can generate accurate test mocks

**Effect vs. module naming:** Effect names are capability identifiers in a separate namespace from code modules. A code module like `Http` provides functions (`Http.get(...)`, `Http.post(...)`), while the corresponding effect capability is `Net`. The mapping:

| Code Module | Effect Capability |
|-------------|------------------|
| `Db` | `Db.Read`, `Db.Write` |
| `Http` | `Net` |
| `Fs` | `Fs.Read`, `Fs.Write` |
| `Uuid` | `Random` |
| `Time` | `Time` |
| `Log` | `Log` |

**Note:** This is *not* an algebraic effect system with handlers. Effects are capability annotations checked at compile time. A function that requires `[Db.Read]` can only be called from a context that has the `Db.Read` capability. Effect handlers may be added in a future version (see Roadmap).

#### Effect Polymorphism

Higher-order functions must be generic over the effects of their closures. Without this, `map`, `filter`, and `reduce` could not accept effectful callbacks, making the language impractical.

```aura
// e is implicitly quantified — no forall needed
map: List a * (a -> b [e]) -> List b [e]
def map(list, f) = {
  // e is an effect variable—map inherits whatever effects f requires
}

filter: List a * (a -> Bool [e]) -> List a [e]
def filter(list, pred) = {
  // If pred is pure (e = []), filter is also pure
}
```

**Inference rules:**
- All free lowercase variables (type and effect) in a signature are implicitly universally quantified
- Effect variables (like `e` above) are inferred at call sites based on the concrete closure passed
- Multiple effect variables combine via union: `combine: (() -> a [e1]) * (() -> b [e2]) -> c [e1, e2]`
- A pure closure (no effects) unifies with any effect variable, producing the empty effect set

### 3.5 Imports and Modules

**Standard imports:**

```aura
use std::collections::{HashMap, HashSet}
use http::Client
use auth::verify_token
```

**Tooling-generated context:**

The compiler generates `aura.manifest.json` containing expanded signatures with effects for all public functions. AI tools and IDEs use this manifest to provide context without cluttering source code.

```bash
# Extract context for a specific function
aura context src/user_service.aura::create_user
# Outputs: function + direct dependencies + types + effect definitions
```

**Visibility:**
- All definitions (functions, types, concepts) are module-private by default
- `pub` makes a definition visible to other modules
- Applies to `def`, `type`, `concept`, and `instance` blocks

**Modules:**

Modules can nest up to 3 levels deep. Deeper nesting triggers a lint warning.

```aura
/// Handles user authentication, registration, and profile management
module user_service

@owner("auth-team")
@since("2024.1")

pub def register(...) -> ... [...]
pub def login(...) -> ... [...]
pub def get_profile(...) -> ... [...]

// Private helpers below
def validate_password(...) -> ...
def hash_password(...) -> ... [Random]
```

**Module metadata** uses `@` annotations (declarative, no runtime behavior):
- Doc comments (`///`) provide semantic description for retrieval
- `@owner("team")` — ownership info
- `@since("version")` — version introduced
- `@deprecated("reason", alternative: "other_fn")` — deprecation

Annotations are compile-time metadata only — they cannot modify behavior, call functions, or generate code. This distinguishes them from decorators (which are forbidden, see Section 10).

### 3.6 Refined Types and Validation

Refined types express constraints on values. They are **runtime-checked wrapper types** (the newtype/smart-constructor pattern), not compile-time-proven propositions.

#### Defining Refined Types

```aura
type NonZero = Int where self != 0
type Positive = Int where self > 0
type NonEmpty a = List a where self.len > 0
type Percentage = Float where self >= 0.0 and self <= 100.0
type Email = String where self.matches(EMAIL_REGEX)
type Bounded (const Min: Int) (const Max: Int) = Int where self >= Min and self <= Max
```

**Note:** Const-parameterized refined types (like `Bounded`) are deferred to Phase 2. Phase 1 supports only literal constraints in `where` clauses.

**Constraint grammar:** The `where` clause supports a restricted expression language:
- Comparisons: `==`, `!=`, `<`, `>`, `<=`, `>=`
- Boolean connectives: `and`, `or`, `not`
- Arithmetic: `+`, `-`, `*`, `/`, `%`
- Field access: `self.field` (for product types)
- Built-in method calls: `self.len`, `self.matches(pattern)`, `self.contains(value)`
- Constants and literals (module-level constants like `EMAIL_REGEX` are permitted)
- No arbitrary function calls, closures, or side effects

#### How Refined Types Work

A refined type is a distinct type that wraps its base type. Values must be explicitly validated at boundaries. The `.new()` constructor returns `Result T ConstraintError`, where `ConstraintError` is a standard library type:

```aura
// Standard library type for refined type validation failures
type ConstraintError {
  message: String
}
```

```aura
// Construction requires validation
let n: Result NonZero ConstraintError = NonZero.new(x)

// Once validated, the refined type is a proof of the constraint
def divide(a: Int, b: NonZero) -> Int = a / b.value  // .value unwraps to the underlying Int

// Calling code must validate at the boundary
match NonZero.new(divisor) {
  Ok(nz) => divide(100, nz),
  Err(e) => handle_zero_divisor()
}
```

#### Unified Error Handling

When a function can fail for multiple reasons, errors unify into a single `Result` via wrapping variants:

```aura
// Error type with wrapping variants for auto-From derivation
type FetchError = NotFound | InvalidInput(ConstraintError) | DbFailed(String)

def fetch_user(id: String) -> Result User FetchError [Db.Read] = {
  let valid_id = NonEmpty.new(id)?  // ConstraintError auto-converts via InvalidInput variant
  Db.query_one("SELECT * FROM users WHERE id = ?", valid_id.value)
}

// Caller handles one Result, not nested layers
match fetch_user(id) {
  Ok(user) => use(user),
  Err(NotFound) => show_not_found(),
  Err(InvalidInput(e)) => handle_bad_input(e),
  Err(DbFailed(msg)) => handle_db_error(msg)
}
```

#### Design Rationale

This approach:
1. **Keeps signatures honest** — what you write is what callers get
2. **Validates at boundaries** — construction is the checkpoint
3. **Unifies errors** — no nested `Result (Result ...) ...`
4. **Is implementable** — newtypes with validation, no dependent types or SMT solvers
5. **Helps AI** — constraints are visible documentation of valid inputs

#### Contracts for Documentation

For documenting complex preconditions that aren't refined types, use `requires`/`ensures`:

```aura
def withdraw(account: Account, amount: Positive) -> Result Account InsufficientFunds
  requires account.status == Active
  ensures result.ok?.balance == account.balance - amount.value
= {
  if account.balance < amount.value {
    return Err(InsufficientFunds)
  }
  Ok(account with { balance: account.balance - amount.value })
}
```

**When to use which:**
- **Refined types:** Data invariants on a single value (`NonEmpty`, `Positive`, `Email`)
- **Contracts:** Relational preconditions involving multiple parameters or complex state

`requires`/`ensures` are:
- Checked at runtime in debug builds
- Documentation for humans and AI
- Not part of the type signature

**Contract expression language:** Contract expressions are a superset of refined type constraints. In addition to the constraint grammar, they support:
- `result` keyword: refers to the function's return value in `ensures` clauses
- Parameter references: any function parameter name can be used directly
- Optional chaining: `result.ok?.field` evaluates to the field if the result is `Ok`, skips the check otherwise
- Result inspection: `result.is_ok()`, `result.is_err()`

### 3.7 Immutability by Default

All bindings are immutable. Mutation requires explicit `mut`.

```aura
let x = 5
x = 6  // Compile error

let mut counter = 0
counter = counter + 1  // OK
```

Local mutation is an implementation detail, not an effect. A function with only local `let mut` and no other effects is still pure:

```aura
// This function is pure—no effects required
def sum_range(n: Int) -> Int = {
  let mut sum = 0
  for i in 1..=n {
    sum = sum + i
  }
  sum
}
```

### 3.8 Error Handling

No exceptions. All errors are values. Errors compose via sum types with wrapping variants.

```aura
type ConfigError = Io(IoError) | Parse(ParseError) | InvalidValue(String)

def parse_config(path: String) -> Result Config ConfigError [Fs.Read] = {
  let content = Fs.read(path)?     // IoError auto-wraps to ConfigError via Io variant
  let parsed = Json.parse(content)? // ParseError auto-wraps via Parse variant
  validate_config(parsed)
}

// Calling code
match parse_config("app.json") {
  Ok(config) => start_app(config),
  Err(Io(_)) => use_defaults(),
  Err(e) => panic("Config error: {e}")
}
```

**Error conversion:** The `?` operator uses the `From` concept to convert between error types. For wrapping variants, `From` is auto-derived (see below). For custom conversion logic, implement `From` manually:

```aura
// Manual From when conversion isn't a simple wrap
instance From timeout::TimeoutError for ConfigError {
  def from(e: timeout::TimeoutError) -> ConfigError = Io(IoError.timeout(e))
}
```

**Automatic `From` derivation:** When a sum type has a single-payload variant that wraps another type, the compiler auto-derives the `From` instance:

```aura
type AppError = Io(IoError) | Db(DbError) | InvalidInput(String)

// Auto-derived by compiler:
// instance From IoError for AppError { def from(e) = Io(e) }
// instance From DbError for AppError { def from(e) = Db(e) }
```

This enables `?` to automatically wrap errors into the appropriate variant.

### 3.9 Pattern Matching

Exhaustive pattern matching on all algebraic types.

```aura
def describe(value: Option Int) -> String = {
  match value {
    Some(n) if n > 0 => "positive: {n}",
    Some(n) if n < 0 => "negative: {n}",
    Some(_) => "zero",
    None => "nothing"
  }
}
```

**Guard exhaustiveness:** When any match arm uses a guard (`if condition`), the compiler cannot prove that the guards cover all cases. Therefore, when guards are present, a catch-all arm (`_` or an unguarded binding pattern) is required for the guarded type. In the example above, `Some(_)` serves as the catch-all for all `Some` values not matched by the guards.

### 3.10 Control Flow

Aura is expression-based: `if`, `match`, and blocks all produce values.

**Conditional expressions:**

```aura
// if/else is always block-delimited and produces a value
let status = if user.is_active { "active" } else { "inactive" }

// Multi-branch
let label = if score >= 90 { "A" }
  else if score >= 80 { "B" }
  else if score >= 70 { "C" }
  else { "F" }
```

There is no `then` keyword. `if` always uses block syntax `{ }`.

**Loops:**

```aura
// for-in loop with ranges
for i in 0..n { ... }      // exclusive: 0, 1, ..., n-1
for i in 0..=n { ... }     // inclusive: 0, 1, ..., n

// for-in loop over collections
for item in items { ... }

// while loop
while condition { ... }
```

**Early return:**

```aura
// return exits the enclosing function immediately
def find_admin(users: List User) -> Option User = {
  for user in users {
    if user.role == Admin { return Some(user) }
  }
  None
}
```

**Loop control:** `break` exits the nearest enclosing loop; `continue` skips to the next iteration.

Loops are statements (produce `()`), not expressions. Use `map`/`filter`/`reduce` for value-producing iteration.

### 3.11 Structured Concurrency

Async is a function modifier, separate from the effect system. A function can be async and pure. There is no `.await` operator — calling an `async def` from another `async def` implicitly awaits (sequential execution). Concurrent execution uses `parallel`, `race`, or `timeout` blocks exclusively. There are no detached tasks.

```aura
async def compute_fibonacci(n: Int) -> Int = {
  // Pure async computation—no effects
  // Recursive calls are sequential (implicit await)
  if n <= 1 { n } else {
    let (a, b) = parallel {
      yield compute_fibonacci(n - 1),
      yield compute_fibonacci(n - 2)
    }
    a + b
  }
}

async def fetch_all(ids: List UUID) -> List (Result User FetchError) [Db.Read] = {
  parallel {
    for id in ids yield fetch_user(id)
  }
}

async def process_with_timeout() -> Result Data Timeout [Net] = {
  timeout(Duration.seconds(5)) {
    fetch_external_data()
  }
}
```

**Concurrency primitives:**

| Primitive | Behavior |
|-----------|----------|
| `parallel { for x in xs yield expr }` | Run all concurrently, collect results |
| `parallel { yield expr1, yield expr2 }` | Run fixed set concurrently, return product type |
| `race { expr1, expr2 }` | Return first to complete, cancel others |
| `timeout(duration) { expr }` | Cancel if duration exceeded |

**Parallel error-handling patterns:**

1. **Fail-fast:** Use `?` inside `yield` — returns `Result (List a) e`, cancels remaining tasks on first error
2. **Collect-all:** No `?` inside `yield` — returns `List (Result a e)`, all tasks run to completion

**Async/sync boundary:**
- Calling an `async def` from a non-async function is a compile error
- The program entry point may be `async def main(...)` to enable top-level async
- For explicitly bridging async into sync code, use `Runtime.block_on(expr)`

**Semantics:**
- **Cancellation:** When a scope exits (timeout, race loser, fail-fast error), child tasks are cancelled
- **Effect propagation:** Child effects bubble up to parent (`parallel` with `[Db.Read]` children requires `[Db.Read]`)

### 3.12 String Interpolation

Strings support interpolation with `{expr}`. The expression must implement the `Display` concept. Use `{{` and `}}` for literal braces.

```aura
let name = "Alice"
let greeting = "Hello, {name}!"  // "Hello, Alice!"
let result = "2 + 2 = {2 + 2}"   // "2 + 2 = 4"
let braces = "Use {{expr}} for interpolation"  // "Use {expr} for interpolation"
```

### 3.13 Functional Update

The `with` syntax creates a copy of a product type with some fields changed (shallow copy).

```aura
let updated = user with { status: Suspended }

// Equivalent to:
let updated = User {
  id: user.id,
  name: user.name,
  email: user.email,
  created: user.created,
  status: Suspended
}
```

Rules:
- Works on product types (structs/records) only
- Shallow copy—nested values are shared, not cloned
- All overridden fields must type-check

### 3.14 Program Entry Point

Every Aura program has a single entry point: a `def main()` function in `module main` (conventionally `src/main.aura`).

```aura
module main

def main() -> Result () AppError [Db.Read, Db.Write, Net, Log, Fs.Read] = {
  let config = load_config("app.toml")?
  let server = start_server(config)?
  server.run()
}
```

**Rules:**
- Return type is `()` (infallible) or `Result () e` (may fail with exit code)
- The effect list declares the **maximum capabilities** available to the program
- All effects used transitively by any called function must be a subset of main's declared effects
- A program with `def main() -> () []` is a pure program with no side effects

### 3.15 Methods

Types can have **inherent methods** defined in `instance` blocks. Methods are functions whose first parameter is `self`.

```aura
type Point {
  x: Float64
  y: Float64
}

instance Point {
  // Inherent method: called as point.distance_to(other)
  def distance_to(self, other: Point) -> Float64 = {
    let dx = self.x - other.x
    let dy = self.y - other.y
    (dx * dx + dy * dy).sqrt()
  }

  // Associated function (no self): called as Point.origin()
  def origin() -> Point = Point { x: 0.0, y: 0.0 }
}
```

**Rules:**
- `self` is always immutable — methods that need to "change" the value return a new value instead
- No `mut self` — this aligns with immutability-by-default (Section 3.7)
- Associated functions (no `self` parameter) are called via `Type.name(...)` syntax
- Concept methods and inherent methods share the same call syntax (`value.method()`)

---

## 4. Memory Management

Aura uses a **mark-sweep garbage collector (GC)** for automatic memory management.

**Design rationale:**
- Simplicity: developers never think about cycles or reference counting
- Correctness: cycles are handled automatically — no `Weak` references needed
- Throughput: no per-operation overhead (no retain/release on every copy)
- AI-friendly: no memory management concepts to reason about in generated code

**Details:**
- All heap values are GC-managed (allocated through the GC allocator)
- `Copy` concept types (primitives, small structs) are stack-allocated and copied
- The GC uses a stop-the-world mark-sweep algorithm initially
- GC roots are tracked via a shadow stack
- Collection is triggered when the heap exceeds a dynamic threshold

```aura
type Node {
  value: Int
  next: Option Node       // Cycles handled automatically by GC
  parent: Option Node     // No special type needed — GC traces all references
}
```

**Performance notes:**
- Hot paths can use `Copy` concept types to avoid GC allocation overhead
- Escape analysis can stack-allocate objects that don't escape the current function
- Future versions may add generational or concurrent collection to reduce pause times

---

## 5. Standard Library Design

### 5.1 Core Types

```aura
// Primitives
Int, Int8, Int16, Int32, Int64
UInt, UInt8, UInt16, UInt32, UInt64
Float32, Float64
Decimal         // Fixed-precision (128-bit IEEE 754 decimal)
BigDecimal      // Arbitrary precision (heap-allocated)
Bool
Char
String

// Compound
Option a       // Some(a) | None
Result a e     // Ok(a) | Err(e)
List a         // Ordered sequence
Map k v        // Key-value mapping (requires k: Hash + Eq)
Set a          // Unique values (requires a: Hash + Eq)
A * B * C      // Product type (tuple) — type syntax
```

Product types use `*` in type position and parentheses in value position: `(1, "hello", true)` has type `Int * String * Bool`. Destructure with `let (a, b, c) = tuple`.

**Collection literal syntax:**

```aura
let list = [1, 2, 3]                     // List Int
let map = Map.from([("a", 1), ("b", 2)]) // Map String Int
let set = Set.from([1, 2, 3])            // Set Int
let tuple = (1, "hello", true)           // Int * String * Bool

// Struct literals use the type name
let user = User { id: 1, name: "Alice" }
```

### 5.2 Common Operations

Consistent naming across all collection types. Collection operations are **eager by default** — each step produces a new collection immediately.

```aura
collection
  |> map((x) -> transform(x))
  |> filter((x) -> predicate(x))
  |> reduce(initial, (acc, x) -> combine(acc, x))
  |> find((x) -> predicate(x))
  |> any((x) -> predicate(x))
  |> all((x) -> predicate(x))
  |> take(n)
  |> skip(n)
  |> sort_by((x) -> x.field)
  |> group_by((x) -> x.field)
```

For deferred evaluation, use the `lazy` adapter. `collect` materializes a lazy pipeline back into a concrete collection:

```aura
collection
  |> lazy
  |> map((x) -> expensive_transform(x))
  |> filter((x) -> predicate(x))
  |> take(10)
  |> collect  // Materializes here—only processes elements as needed
```

---

## 6. Tooling Requirements

### 6.1 Compiler

- Fast incremental compilation
- Clear, actionable error messages
- Deterministic builds

### 6.2 AI Integration Points

**Manifest Generation:**
Compiler generates `aura.manifest.json` containing:
- All public function signatures with effects
- Module documentation
- Dependency graph
- Type definitions

This manifest is optimized for AI consumption.

**Semantic Index:**
Built-in support for generating semantic embeddings of code for retrieval:

```bash
aura index ./src --output embeddings.idx
```

**Context Extraction:**
Tool to extract minimal context for a given function:

```bash
aura context src/user_service.aura::create_user
# Outputs: function + direct dependencies + types + effect definitions
# Minimal tokens needed to understand this function
```

### 6.3 Formatter

Single canonical format. No configuration. Like `gofmt`.

```bash
aura fmt ./src
```

### 6.4 Linter

Built-in linter enforcing:
- Effect correctness
- Naming conventions
- Complexity limits
- Module depth (warning at >3 levels)

```bash
aura lint ./src
```

### 6.5 Package Manager

```bash
aura add http
aura remove http
aura update
```

Dependencies are locked and vendored by default. No version ranges.

---

## 7. Syntax Summary

```aura
// Module declaration
/// Order processing service
module order_service

// Imports
use std::collections::HashMap
use http::Client

// Refined type definitions
type NonZero = Int where self != 0
type Positive = Int where self > 0
type NonEmpty a = List a where self.len > 0

// Algebraic type definition
type Status = Pending | Processing | Complete | Failed String

// Product type definition
type Order {
  id: UUID
  items: List LineItem
  status: Status
  total: Decimal
}

// Concept implementation
instance Display for Order {
  def display(self) -> String = "Order {self.id}: {self.status}"
}

// Function with effects and contract (monomorphic — no standalone annotation needed)
pub def process_order(order: Order) -> Result Order ProcessError [Db.Write, Net, Log]
  requires order.status == Pending
  ensures result.ok?.status == Processing or result.is_err()
= {
  Log.info("Processing order {order.id}")

  let validated = validate_items(order.items)?
  let charged = Payment.charge(order.total)?

  let updated = order with { status: Processing }
  Db.update(updated)?

  Ok(updated)
}

// Function with refined input
def calculate_total(items: NonEmpty LineItem) -> Decimal = {
  items.value
    |> map((item) -> item.price * item.quantity)
    |> sum
}

// Pure function (no effects) — inline types on parameters
def add(a: Int, b: Int) -> Int = a + b

// Pattern matching
def status_message(status: Status) -> String = {
  match status {
    Pending => "Waiting to process",
    Processing => "In progress",
    Complete => "Done",
    Failed(reason) => "Failed: {reason}"
  }
}

// Error handling with unified Result (wrapping variants enable auto-From)
type OrderError = Validation(String) | Process(ProcessError) | Db(DbError)

def handle_order(order: Order) -> Result String OrderError [Db.Write, Net, Log] = {
  let processed = process_order(order)?  // ProcessError auto-wraps via Process variant
  Ok("Order {processed.id} processing")
}

// Async with structured concurrency (fail-fast pattern)
async def fetch_enriched_orders(ids: NonEmpty UUID) -> Result (List EnrichedOrder) FetchError [Db.Read, Net] = {
  parallel {
    for id in ids.value yield {
      let order = Db.get_order(id)?
      let user = Http.get("/users/{order.user_id}")?
      EnrichedOrder { order, user }
    }
  }
}

// Lambda syntax
def apply_discount(items: List LineItem, rate: Float) -> List LineItem = {
  items |> map((item) -> item with { price: item.price * (1.0 - rate) })
}

// Standalone type annotation for polymorphic function with concept bounds
max: forall (Ord a). a * a -> a
def max(a, b) = if a.compare(b) == Greater { a } else { b }

// Polymorphic function without bounds (forall not needed — a is implicitly quantified)
identity: a -> a
def identity(x) = x
```

---

## 8. Implementation Roadmap

### Phase 1: Core Language & Compiler
- Lexer and parser
- Type system with inference and implicit quantification
- Concept system
- LLVM code generation (native executables from day one)
- Memory management (mark-sweep GC) with closure capture semantics
- Control flow (`if`/`else`, `for`, `while`, `return`, `break`/`continue`)
- Basic effect checking with effect polymorphism
- Program entry point (`def main()`)
- Method syntax (`instance` blocks)
- Refined types (literal constraints only)
- String interpolation with brace escaping
- Pipeline operator
- Automatic `From` derivation for wrapping variants

### Phase 2: Advanced Features
- Effect verification (full transitive checking)
- Optimization passes (escape analysis, GC-aware optimizations)
- WASM target (secondary compilation target)
- Const-parameterized refined types (`Bounded (const Min) (const Max)`)

### Phase 3: Standard Library
- Core types and concepts
- Collections (eager by default)
- Lazy collection pipelines (`lazy`/`collect`)
- IO effects
- Async runtime with structured concurrency

### Phase 4: Tooling
- Formatter
- Linter
- Language server (LSP)
- Package manager

### Phase 5: AI Integration
- Manifest generator
- Semantic indexer
- Context extractor
- IDE plugins with AI assist

### Future: Effect Handlers (Optional)
- Full algebraic effects with handlers
- Requires runtime support for delimited continuations
- Enables custom control flow and effect interpretation

---

## 9. Open Questions

1. **Interop:** How to interface with existing languages (FFI)?

2. **Compilation target:** LLVM, WASM, or both?

3. **Gradual adoption:** Can Aura compile to/from other languages for migration?

4. **Refined type composition:** How do refined types compose?
   ```aura
   type PositiveNonZero = Positive  // Positive already implies NonZero
   ```

5. **Object graph complexity lint:** Should the compiler warn about deeply recursive type definitions that may cause excessive GC tracing? (With mark-sweep GC, cycles are handled automatically — this is a performance concern, not a correctness concern.)

6. **Module inference from file path:** Should the `module` declaration be optional when the module name matches the file path (e.g., `src/user_service.aura` implies `module user_service`)? This would save tokens but conflicts with "explicit over implicit."

---

## 10. Design Anti-Patterns to Avoid

These patterns are explicitly forbidden or discouraged:

| Pattern | Why it's harmful for AI |
|---------|------------------------|
| Inheritance | Creates implicit behavior, requires tracing class hierarchy |
| Macros | Transform syntax, hide actual code |
| Ad-hoc operator overloading | Same symbol, different meanings without concept-based dispatch (note: concept-based operators like `Add.add` for `+` are permitted) |
| Implicit conversions | Hidden behavior |
| Global state | Non-local effects |
| Reflection/metaprogramming | Runtime code modification |
| Convention over configuration | Implicit behavior based on naming/structure |
| Monkey patching | Runtime modification of existing code |
| Decorators that modify behavior | Hidden control flow |
| Method chaining on mutable objects | Hard to trace state |
| Hidden signature transforms | Written code should match actual behavior |

---

## 11. Success Metrics

Aura succeeds if:

1. **Context efficiency:** An AI can correctly understand and modify a function with <2000 tokens of context on average

2. **Correctness:** AI-generated Aura code has >90% first-attempt compilation success rate

3. **Predictability:** Given a function signature with effects, AI can accurately predict implementation patterns

4. **Retrieval:** Semantic search over Aura codebases achieves >85% precision for "find code that does X"

5. **Human readability:** Developers report Aura as "easy to read" at rates comparable to Python/Go

---

## Appendix A: Comparison with Existing Languages

| Feature | Aura | Go | Rust | Python | Koka |
|---------|------|-----|------|--------|------|
| Tracked effects | Native | No | Partial* | No | Native (algebraic) |
| Null safety | Yes | No | Yes | No | Yes |
| Type inference | Yes | Limited | Yes | Dynamic | Yes |
| Single formatting | Yes | Yes | No | No | No |
| Concepts/Typeclasses | Yes (concepts) | Interfaces | Yes (traits) | Protocols | Yes |
| Memory model | GC (mark-sweep) | GC | Ownership | GC | GC |
| AI-oriented design | Primary | No | No | No | No |
| Training data volume | New | High | Medium | Highest | Low |

*Rust tracks `Send`, `Sync`, `unsafe`, and async at compile time, but not general effects.

---

## Appendix B: Example Project Structure

```
my_project/
├── aura.toml              # Project configuration
├── aura.lock              # Locked dependencies
├── aura.manifest.json     # Generated: AI-readable manifest
├── src/
│   ├── main.aura          # Entry point
│   ├── user_service.aura  # User module
│   ├── order_service.aura # Order module
│   └── types.aura         # Shared types
├── tests/
│   ├── user_test.aura
│   └── order_test.aura
└── vendor/                # Vendored dependencies
```

---

## Appendix C: Glossary

- **GC:** Garbage Collection—automatic memory management via mark-sweep tracing
- **Concept:** A set of methods that types can implement for polymorphism (called "traits" in Rust, "type classes" in Haskell)
- **Context-completeness:** Property of code that can be understood without external references
- **Effect:** A declared capability requirement of a function (IO, state change, etc.)
- **Effect polymorphism:** The ability for higher-order functions to be generic over the effects of their closure arguments
- **forall:** Keyword for declaring concept bounds on generic type signatures (e.g., `forall (Ord a). a * a -> a`). Not needed for basic quantification—free lowercase type variables are implicitly universally quantified
- **Implicit quantification:** All free lowercase type and effect variables in a type signature are universally quantified without explicit `forall`
- **Inherent method:** A method defined directly on a type via `instance Type { ... }`, as opposed to a concept method
- **Pipeline operator:** The `|>` operator that passes the left-hand value as the first argument to the right-hand function
- **Product type:** A composite type combining multiple values; type syntax `A * B * C`, value syntax `(a, b, c)`
- **Refined type:** A wrapper type with an attached constraint validated at construction
- **Self / self:** `Self` (uppercase) refers to the implementing type in concept and instance blocks; `self` (lowercase) refers to the current instance value as a method parameter
- **Semantic density:** Ratio of meaning to tokens
- **Token efficiency:** Minimizing tokens needed to express or understand code
- **Tracked effects:** Compile-time verification that functions only use declared capabilities
- **Variant resolution:** How bare variant names in pattern matching and expressions are resolved to their sum type based on context

---

## Appendix D: Changelog

### v0.6 (Current)
- Replaced ARC memory management with mark-sweep garbage collector (GC)
- Removed `Weak a` type — cycles handled automatically by GC
- Updated Section 4 (Memory Management) for GC architecture
- Updated closure capture semantics: GC-managed environments instead of ARC refcounting
- Replaced "Interpreter for rapid iteration" with LLVM code generation in Phase 1 roadmap
- Moved code generation from Phase 2 to Phase 1 (LLVM-first, no interpreter)
- Added WASM as secondary target in Phase 2
- Updated comparison table: memory model from ARC to GC
- Updated glossary: replaced ARC entry with GC entry
- Updated cycle lint open question: now about GC tracing performance, not reference cycles

### v0.5
- Removed inline union types; all sum types must be named (nominal)
- Added variant resolution rules: bare variants resolved by context, qualified when ambiguous (`Status.Pending`)
- Unified `if` to block form only: `if cond { ... } else { ... }` (removed `then` keyword)
- Added Section 3.10: Control Flow (`if`/`else`, `for`/`while` loops, ranges, `return`, `break`/`continue`)
- Standalone type annotations are now optional; only needed for polymorphic functions with `forall` bounds
- Added implicit quantification: free lowercase type/effect variables are universally quantified without `forall`
- Removed unnecessary `forall e.` from effect polymorphism examples
- Extended operator concept sugar to include `==`/`!=`/`<`/`>`/`<=`/`>=` for `Eq`/`Ord`
- Added closure capture semantics: capture by reference with GC-managed environments
- Added visibility rules: module-private by default, `pub` for public
- Added async/sync boundary specification: calling async from sync is a compile error
- Added generic product type definition example: `type Pair a b { first: a, second: b }`
- Clarified product type (tuple) value syntax: type `A * B * C`, value `(a, b, c)`
- Added automatic `From` derivation for sum type wrapping variants
- Standardized error handling: errors use wrapping variants for auto-`From` derivation (`type AppError = Io(IoError) | ...`)
- Introduced `ConstraintError` as standard library type returned by refined type `.new()` constructors
- Fixed FetchError example: pattern matching now consistent with variant definitions
- Fixed ConfigError example to use wrapping variants with auto-`From`
- Fixed `concept Add` parameter naming collision (`rhs: rhs` → `other: rhs`)
- Specified `@` annotation syntax as compile-time metadata (distinct from forbidden decorators)
- Specified empty effect list convention: omitted list = pure, explicit `[]` equivalent
- Specified that module-level constants are permitted in refined type `where` clauses
- Added new glossary entries: implicit quantification, product type, Self/self, variant resolution
- Updated `forall` glossary entry to clarify it's only for concept bounds
- Removed "effect inference" from open questions (decided: always explicit)
- Added "module inference from file path" open question
- Renumbered Sections 3.10–3.14 to 3.11–3.15 to accommodate new Control Flow section

### v0.4
- Reskinned syntax away from Rust-like conventions to give Aura its own identity
- Renamed `fn` keyword to `def` for function definitions
- Renamed `trait` keyword to `concept` for type class definitions
- Renamed `impl` keyword to `instance` for concept implementations and inherent method blocks
- Adopted Haskell-style generics: `List a`, `Result a e` instead of `List<T>`, `Result<T, E>`
- Added `forall` keyword for universal quantification and concept bounds: `forall (Ord a). a * a -> a`
- Changed lambda syntax from `|x| expr` to `(x) -> expr`
- Changed tuple type syntax from `(A, B, C)` to `A * B * C` (product types)
- Changed associated type access from `Self::Output` to `Self.Output`
- Changed function body syntax to use `=` before the body: `def f(x: Int) -> Int = { ... }`
- Added standalone type annotation style (Haskell-inspired): `name: Type` on its own line before `def`
- Changed nested generic syntax to use parenthesization: `List (Result User Error)` instead of `List<Result<User, Error>>`
- Convention: type variables are lowercase (`a`, `b`, `e`), concrete types uppercase (`Int`, `User`)
- Updated all code examples, glossary, comparison table, and roadmap to use new syntax

### v0.3
- Clarified sum type syntax: named vs inline union types with structural/nominal distinction
- Added arithmetic concept note: `+` is sugar for `Add.add`, not ad-hoc overloading
- Reordered `From a`, `Into a` with auto-derivation note; fixed error conversion example to use `From`
- Specified pipeline operator semantics: `a |> f(b, c)` desugars to `f(a, b, c)`
- Added effect-module naming clarification with mapping table
- Added `Random` effect to `create_user` signature (for `Uuid.new()`)
- Removed `...data` spread syntax; replaced with explicit field assignments
- Added effect polymorphism as core feature (no longer an open question)
- Added refined type constraint grammar specification
- Added contract expression language specification
- Deferred const-parameterized refined types to Phase 2
- Added guard exhaustiveness rules for pattern matching
- Removed `.await`; sequential calls implicitly await, concurrency via `parallel`/`race`/`timeout` only
- Specified two parallel patterns: fail-fast (with `?`) and collect-all
- Added `{{`/`}}` escape sequences for literal braces in string interpolation
- Removed periodic cycle detection; adopted Weak-only model with compiler cycle warnings
- Specified eager-by-default collections with `lazy`/`collect` for deferred evaluation
- Added program entry point specification (Section 3.13)
- Added method syntax specification (Section 3.14)
- Fixed `NonEmpty (List LineItem)` to `NonEmpty LineItem` (double-wrapping bug)
- Fixed `fetch_enriched_orders` return type to `Result (List EnrichedOrder) FetchError`
- Rewrote anti-pattern "Operator overloading" to "Ad-hoc operator overloading"
- Removed resolved open questions; renumbered remaining
- Added glossary entries: effect polymorphism, inherent method, pipeline operator
- Updated implementation roadmap phases

### v0.2
- Clarified effect system as "tracked effects" (capability annotations), not algebraic effects
- Added concept system specification
- Added memory management model (ARC)
- Changed refined types to be explicit wrapper types with `.new()` and `.value`
- Unified error handling—no nested `Result (Result ...) ...`
- Removed `mut` from effect system (local mutation is not an effect)
- Separated `async` from effects (it's an execution model, not a capability)
- Standardized effect naming to capability level (`Log` not `Log.Info`)
- Replaced verbose imports with tooling-generated context
- Added explicit lambda syntax for clarity
- Changed `Decimal` to fixed-precision; added `BigDecimal` for arbitrary
- Specified collection literal syntax to avoid ambiguity with struct literals
- Relaxed module nesting to 3 levels with lint warning
- Added string interpolation and `with` syntax specifications
- Added structured concurrency semantics

### v0.1
- Initial proposal

---

*End of proposal*